//
// Created by kellerberrin on 16/5/20.
//

#ifndef KGL_VARIANT_FACTORY_VCF_EVIDENCE_H
#define KGL_VARIANT_FACTORY_VCF_EVIDENCE_H


#include "kel_exec_env.h"
#include "kgl_variant_factory_vcf_parse_header.h"

#include <string>
#include <array>


namespace kellerberrin::genome {   //  organization level namespace




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A single evidence index, used to lookup an info field in a variant.
// The same index object can be used to look up data in all variants generated by a particular.
class InfoEvidenceHeader; // Fwd.
enum class InfoEvidenceType { Float, Integer, String, FloatArray, IntegerArray, StringArray, IntegerAllele, FloatAllele, StringAllele, Boolean, NotImplemented};
class InfoEvidenceIndex {

public:

  InfoEvidenceIndex(VCFInfoRecord vcfInfoRecord,
                    InfoEvidenceType type,
                    size_t index,
                    std::shared_ptr<const InfoEvidenceHeader> info_evidence_header)
  : vcfInfoRecord_(std::move(vcfInfoRecord)),
    type_(type),
    index_(index),
    info_evidence_header_(std::move(info_evidence_header)) {}
  InfoEvidenceIndex(const InfoEvidenceIndex&) = default; // Can be copied but not created externally.
  ~InfoEvidenceIndex() = default;

  [[nodiscard]] const VCFInfoRecord& infoRecord() const { return vcfInfoRecord_; }
  [[nodiscard]] InfoEvidenceType evidenceType() const { return type_; }

private:

  const VCFInfoRecord vcfInfoRecord_;
  const InfoEvidenceType type_;
  const size_t index_;
  std::shared_ptr<const InfoEvidenceHeader> info_evidence_header_; // Ensure the index knows which header it belongs to.

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The index structure for the INFO evidence. This structure is held in common via shared_ptrs by all variants that
// subscribed to a particular set of INFO fields.
using InfoIndexMap = std::map<std::string, InfoEvidenceIndex>;
class InfoTypeCount {

public:

  InfoTypeCount() { reset(); }
  ~InfoTypeCount() = default;

  size_t floatCount() const { return float_count_; }
  size_t integerCount() const { return integer_count_; }
  size_t stringCount() const { return string_count_; }
  size_t floatArrayCount() const { return float_array_count_; }
  size_t integerArrayCount() const { return integer_array_count_; }
  size_t stringArrayCount() const { return string_array_count_; }
  size_t floatAlleleCount() const { return float_allele_count_; }
  size_t integerAlleleCount() const { return integer_allele_count_; }
  size_t stringAlleleCount() const { return string_allele_count_; }
  size_t booleanCount() const { return boolean_count_; }

  std::optional<InfoIndexMap> generateEvidenceIndex(const VCFInfoRecordMap& vcf_info_map);
  static InfoEvidenceType convertVCFType(const VCFInfoRecord& vcf_info_item);
  void incrementCount(InfoEvidenceType type);

private:

  size_t float_count_{0};
  size_t integer_count_{0};
  size_t string_count_{0};
  size_t float_array_count_{0};
  size_t integer_array_count_{0};
  size_t string_array_count_{0};
  size_t float_allele_count_{0};
  size_t integer_allele_count_{0};
  size_t string_allele_count_{0};
  size_t boolean_count_{0};

  constexpr static const char* INTEGER_ = "Integer";
  constexpr static const char* FLOAT_ = "Float";
  constexpr static const char* FLAG_ = "Flag";
  constexpr static const char* CHAR_STRING_ = "Character";
  constexpr static const char* STRING_ = "String";
  constexpr static const char* SCALAR_ = "1";
  constexpr static const char* ALLELE_ = "A";
  constexpr static const char* FLAG_SCALAR_ = "0";
  constexpr static const char* INDETERMINATE_COUNT_ = ".";

  void reset();

};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// An indexed map of InfoEvidenceIndex. There is only one of these held by all variants with INFO evidence fields.
class InfoEvidenceHeader {

public:

  explicit InfoEvidenceHeader() {}
  InfoEvidenceHeader(const InfoEvidenceHeader&) = delete;
  ~InfoEvidenceHeader() = default;

  std::optional<const InfoEvidenceIndex> getIndex(const std::string& info) const;
  const InfoIndexMap& getMap() const { return info_index_map_; }

  // Note that this routine takes a shared_ptr to itself obtained from the info data factory. This is passed onto data objects.
  [[nodiscard]] bool setupEvidenceHeader(const VCFInfoRecordMap& vcf_info_map, std::shared_ptr<const InfoEvidenceHeader> self_ptr);


private:

  InfoIndexMap info_index_map_;


};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the per variant INFO data block.
// Generated from the parser data block by specifying the Allele index.
class EvidenceFactory; // Fwd.
class MultipleAlleleDataBlock;
class InfoDataBlock {

public:

  friend MultipleAlleleDataBlock;
  friend EvidenceFactory;

  InfoDataBlock(std::shared_ptr<InfoEvidenceHeader> info_evidence_header) : info_evidence_header_(std::move(info_evidence_header)) {}
  InfoDataBlock(const InfoEvidenceHeader&) = delete;
  ~InfoDataBlock() = default;

private:

  std::shared_ptr<InfoEvidenceHeader> info_evidence_header_; // The data header.

  // The stored data.
  std::vector<std::pair<bool, double>> float_data_;
  std::vector<std::pair<bool, long>> integer_data_;
  std::vector<std::pair<bool, std::string>> string_data_;
  std::vector<std::pair<bool, std::vector<double>>> float_array_data_;
  std::vector<std::pair<bool, std::vector<long>>> integer_array_data_;
  std::vector<std::pair<bool, std::vector<std::string>>> string_array_data_;


};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the INFO data block generated by parsing a VCF record and contains multiple allele information for multiple alternative allele VCF records.
// A single variant (one allele per variant) InfoDataBlock is constructed by specifying it's index. The order it appears in the alternative
// allele field. For example if the VCF alternative allele field contains the following 3 alleles "A,AAA,AAAA", the index value to
// return the InfoDataBlock data from this object for the variant with the alternative allele "AAA" is 1, "A" is 0 and "AAAA" is 2.
// Important - this data structure is only returned from the EvidenceFactory object if there are multiple alternative alleles.
// If there is only one alternative allele (the majority of cases) then the InfoDataBlock above is returned.
// Note that the InfoEvidenceHeader structure only accesses the InfoDataBlock data, the data in this object cannot be accessed.

class MultipleAlleleDataBlock {

public:

  friend EvidenceFactory;

  MultipleAlleleDataBlock(const MultipleAlleleDataBlock&) = delete;
  ~MultipleAlleleDataBlock() = default;

  size_t alleleCount() const { return std::max(std::max(float_allele_data_.size(), integer_allele_data_.size()), string_allele_data_.size()); }
  std::unique_ptr<const InfoDataBlock> getAlleleInfoData(size_t index) const;

private:

  MultipleAlleleDataBlock(std::shared_ptr<InfoEvidenceHeader> info_evidence_header) : common_allele_data_(std::move(info_evidence_header)) {}

  // The stored data.
  // All common allele data.
  InfoDataBlock common_allele_data_;
  // The per allele data.
  std::vector<std::pair<bool, std::vector<double>>> float_allele_data_;
  std::vector<std::pair<bool, std::vector<long>>> integer_allele_data_;
  std::vector<std::pair<bool, std::vector<std::string>>> string_allele_data_;


};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The evidence factory creates a common evidence lookup object for all variants (to optimize memory usage).
// The evidence factory also creates an evidence object for each variant.

// createVariantEvidence() either returns a single data block, InfoDataBlock for a single alternate allele or
// a MultipleAlleleDataBlock data block for a multiple alternative allele VCF record.
using InfoDataPair = std::pair<std::optional<std::shared_ptr<InfoDataBlock>>, std::optional<std::unique_ptr<MultipleAlleleDataBlock>>>;
class EvidenceFactory {

public:

  explicit EvidenceFactory(const EvidenceInfoSet& evidence_map)
  : evidence_map_(evidence_map),
    info_evidence_header_(std::make_shared<InfoEvidenceHeader>()) {}
  ~EvidenceFactory() = default;

  void availableInfoFields(const VCFInfoRecordMap& vcf_info_map);
  [[nodiscard]] const VCFInfoRecordMap& availableInfoFields() const { return all_available_map_; }
  [[nodiscard]] InfoDataPair createVariantEvidence(std::string&& info);

private:

  // The evidence fields specified in the runtime XML file.
  const EvidenceInfoSet evidence_map_;
  // available info fields parsed from the VCF header.
  VCFInfoRecordMap active_info_map_;
  // All available info fields.
  VCFInfoRecordMap all_available_map_;
  // The info header block
  std::shared_ptr<InfoEvidenceHeader> info_evidence_header_;

  void test1(std::string& info);
  void test2(std::string& info);


};



} // namespace





#endif //KGL_VARIANT_FACTORY_VCF_EVIDENCE_H
