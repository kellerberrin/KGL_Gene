//
// Created by kellerberrin on 16/5/20.
//

#ifndef KGL_VARIANT_FACTORY_VCF_EVIDENCE_H
#define KGL_VARIANT_FACTORY_VCF_EVIDENCE_H


#include "kel_exec_env.h"
#include "kgl_variant_factory_vcf_parse_header.h"
#include "kgl_variant_factory_vcf_parse_info.h"

#include <string>
#include <array>


namespace kellerberrin::genome {   //  organization level namespace




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A single evidence index, used to lookup an info field in a variant.
// The same index object can be used to look up data in all variants generated by a particular.
class InfoEvidenceHeader; // Fwd.
// Defines the applicability of the data.
enum class InfoEvidenceApp {
  GeneralScalar,   // General single valued data.
  GeneralArray,    // General array valued data
  AlternateAllele,  // Applies to the Alternate Alleles. Can be a single value for all alt. alleles or a vector of values for each alt. allele.
  AllAllele, // Applies to all Alleles including the reference allele. Can be a single value for all alleles or a vector of values for each allele.
  Genotype,  // Applies to all defined genotypes in the VCF file (if any). Can be a single value or a vector of values for each genotype.
  NotImplemented  // Unknown (number, type) tuple.
};

// Defines how the data is represented.
enum class InfoEvidenceImpl {
  Boolean,
  Integer,
  Float,
  String,
  IntegerArray,
  StringArray,
  FloatArray,
  NotImplemented  // Unknown (number, type) tuple.
};

class InfoEvidenceTypePair {

public:

  InfoEvidenceTypePair(const InfoEvidenceApp type_application, InfoEvidenceImpl type_representation)
  : type_application_(type_application), type_representation_(type_representation) {}
  InfoEvidenceTypePair(const InfoEvidenceTypePair&) = default;
  ~InfoEvidenceTypePair() = default;


  [[nodiscard]] InfoEvidenceApp InfoApp() const { return type_application_; }  // The info number field
  [[nodiscard]] InfoEvidenceImpl InfoType() const { return type_representation_; }     // The info type field

private:

  InfoEvidenceApp type_application_;   // The info number field
  InfoEvidenceImpl type_representation_;     // The info type field

};

class InfoEvidenceIndex {

public:

  InfoEvidenceIndex(VCFInfoRecord vcfInfoRecord,
                    InfoEvidenceTypePair type,
                    size_t index,
                    std::shared_ptr<const InfoEvidenceHeader> info_evidence_header)
  : vcfInfoRecord_(std::move(vcfInfoRecord)),
    type_(type),
    index_(index),
    info_evidence_header_(std::move(info_evidence_header)) {}

  InfoEvidenceIndex(const InfoEvidenceIndex &) = default; // Can be copied but not created externally.
  ~InfoEvidenceIndex() = default;

  [[nodiscard]] const VCFInfoRecord &infoRecord() const { return vcfInfoRecord_; }

  [[nodiscard]] InfoEvidenceTypePair evidenceType() const { return type_; }

private:

  const VCFInfoRecord vcfInfoRecord_;
  const InfoEvidenceTypePair type_;
  const size_t index_;
  std::shared_ptr<const InfoEvidenceHeader> info_evidence_header_; // Ensure the index knows which header it belongs to.

};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The index structure for the INFO evidence. This structure is held in common via shared_ptrs by all variants that
// subscribed to a particular set of INFO fields.
using InfoIndexMap = std::map<std::string, InfoEvidenceIndex>;

class InfoTypeCount {

public:

  InfoTypeCount() { reset(); }

  ~InfoTypeCount() = default;

  std::optional<InfoIndexMap> generateEvidenceIndex(const VCFInfoRecordMap &vcf_info_map);

  static const InfoEvidenceTypePair evidenceType(const VCFInfoRecord &vcf_info_item);

private:

  constexpr static const char *INTEGER_ = "Integer";
  constexpr static const char *FLOAT_ = "Float";
  constexpr static const char *FLAG_ = "Flag";
  constexpr static const char *CHAR_STRING_ = "Character";
  constexpr static const char *STRING_ = "String";
  constexpr static const char *SCALAR_ = "1";
  constexpr static const char *AlTERNATIVE_ALLELE_ = "A";
  constexpr static const char *ALL_ALLELE_ = "R";
  constexpr static const char *ALL_GENOTYPES_ = "G";
  constexpr static const char *FLAG_SCALAR_ = "0";
  constexpr static const char *INDETERMINATE_COUNT_ = ".";

  void reset();

// Lookup number and type combinations and return a pair of formal info types.
  static bool isVectorType(const std::string& type); // returns true if a number > 1 used in the lambdas below.
  using InfoTypeLookupTable = std::pair<InfoEvidenceTypePair, std::function<bool(std::string number, std::string type)>>;
  static const std::vector<InfoTypeLookupTable> type_definitions_;

};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Table to define the INFO field data types
inline const std::vector<InfoTypeCount::InfoTypeLookupTable> InfoTypeCount::type_definitions_ = {

// Boolean types (assume no arrays of flags).
{{InfoEvidenceApp::GeneralScalar, InfoEvidenceImpl::Boolean}, [](const std::string& type, const std::string& number) { return type == FLAG_ and number == FLAG_SCALAR_; }},
{{InfoEvidenceApp::AlternateAllele, InfoEvidenceImpl::Boolean}, [](const std::string& type, const std::string& number) { return type == FLAG_ and number == AlTERNATIVE_ALLELE_; }},
{{InfoEvidenceApp::AllAllele, InfoEvidenceImpl::Boolean}, [](const std::string& type, const std::string& number) { return type == FLAG_ and number == ALL_ALLELE_; }},
{{InfoEvidenceApp::Genotype, InfoEvidenceImpl::Boolean}, [](const std::string& type, const std::string& number) { return type == FLAG_ and number == ALL_GENOTYPES_; }},
// String types.
{{InfoEvidenceApp::GeneralScalar, InfoEvidenceImpl::String}, [](const std::string& type, const std::string& number) { return type == STRING_ and number == SCALAR_; }},
{{InfoEvidenceApp::AlternateAllele, InfoEvidenceImpl::StringArray}, [](const std::string& type, const std::string& number) { return type == STRING_ and number == AlTERNATIVE_ALLELE_; }},
{{InfoEvidenceApp::AllAllele, InfoEvidenceImpl::StringArray}, [](const std::string& type, const std::string& number) { return type == STRING_ and number == ALL_ALLELE_; }},
{{InfoEvidenceApp::Genotype, InfoEvidenceImpl::StringArray}, [](const std::string& type, const std::string& number) { return type == STRING_ and number == ALL_GENOTYPES_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::StringArray}, [](const std::string& type, const std::string& number) { return type == STRING_ and number == INDETERMINATE_COUNT_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::StringArray}, [](const std::string& type, const std::string& number) { return type == STRING_ and isVectorType(number); }},

// Float types.
{{InfoEvidenceApp::GeneralScalar, InfoEvidenceImpl::Float}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and number == SCALAR_; }},
{{InfoEvidenceApp::AlternateAllele, InfoEvidenceImpl::FloatArray}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and number == AlTERNATIVE_ALLELE_; }},
{{InfoEvidenceApp::AllAllele, InfoEvidenceImpl::FloatArray}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and number == ALL_ALLELE_; }},
{{InfoEvidenceApp::Genotype, InfoEvidenceImpl::FloatArray}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and number == ALL_GENOTYPES_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::FloatArray}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and number == INDETERMINATE_COUNT_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::FloatArray}, [](const std::string& type, const std::string& number) { return type == FLOAT_ and isVectorType(number); }},

// Integer types.
{{InfoEvidenceApp::GeneralScalar, InfoEvidenceImpl::Integer}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and number == SCALAR_; }},
{{InfoEvidenceApp::AlternateAllele, InfoEvidenceImpl::IntegerArray}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and number == AlTERNATIVE_ALLELE_; }},
{{InfoEvidenceApp::AllAllele, InfoEvidenceImpl::IntegerArray}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and number == ALL_ALLELE_; }},
{{InfoEvidenceApp::Genotype, InfoEvidenceImpl::IntegerArray}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and number == ALL_GENOTYPES_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::IntegerArray}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and number == INDETERMINATE_COUNT_; }},
{{InfoEvidenceApp::GeneralArray, InfoEvidenceImpl::IntegerArray}, [](const std::string& type, const std::string& number) { return type == INTEGER_ and isVectorType(number); }},

};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// An indexed map of InfoEvidenceIndex. There is only one of these held by all variants with INFO evidence fields.
class InfoSubscribed {

public:

  InfoSubscribed(const VCFInfoRecord& vcf_info_record)
  : vcf_info_record_(vcf_info_record), data_type_(InfoTypeCount::evidenceType(vcf_info_record)) {}
  ~InfoSubscribed() = default;

  [[nodiscard]] const VCFInfoRecord& infoRecord() const { return vcf_info_record_; }
  [[nodiscard]] const InfoEvidenceTypePair& infoType() const { return data_type_; }

private:

  VCFInfoRecord vcf_info_record_;
  InfoEvidenceTypePair data_type_;

};
using InfoSubscribedMap = std::map<std::string, InfoSubscribed>;

class InfoEvidenceHeader {

public:

  explicit InfoEvidenceHeader() {}

  InfoEvidenceHeader(const InfoEvidenceHeader &) = delete;

  ~InfoEvidenceHeader() = default;

  std::optional<const InfoEvidenceIndex> getIndex(const std::string &info) const;

  const InfoIndexMap &getMap() const { return info_index_map_; }

  // Note that this routine takes a shared_ptr to itself obtained from the info data factory. This is passed onto data objects.
  [[nodiscard]] bool
  setupEvidenceHeader(const InfoSubscribedMap &vcf_info_map, std::shared_ptr<const InfoEvidenceHeader> self_ptr);


private:

  InfoIndexMap info_index_map_;


};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This is the per variant INFO data block.
// Generated from the parser data block by specifying the Allele index.
class EvidenceFactory; // Fwd.

class InfoDataBlock {

public:

  friend EvidenceFactory;

  InfoDataBlock(std::shared_ptr<InfoEvidenceHeader> info_evidence_header) : info_evidence_header_(
  std::move(info_evidence_header)) {}
  InfoDataBlock(const InfoEvidenceHeader &) = delete;
  ~InfoDataBlock() = default;

private:

  std::shared_ptr<InfoEvidenceHeader> info_evidence_header_; // The data header.

  // The stored data.
  std::vector<bool> bool_data_;
  std::vector<InfoParserFloat> float_data_;
  std::vector<InfoParserInteger> integer_data_;
  std::vector<InfoParserString> string_data_;
  std::vector<InfoParserFloatArray> float_array_data_;
  std::vector<InfoParserIntegerArray> integer_array_data_;
  std::vector<InfoParserStringArray> string_array_data_;


};


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// The evidence factory creates a common evidence lookup object for all variants (to optimize memory usage).
// The evidence factory also creates an evidence object for each variant.

// createVariantEvidence() either returns a single data block, InfoDataBlock for a single alternate allele or
// a MultipleAlleleDataBlock data block for a multiple alternative allele VCF record.
using InfoDataEvidence = std::optional<std::shared_ptr<InfoDataBlock>>;
class EvidenceFactory {

public:

  explicit EvidenceFactory(const EvidenceInfoSet& evidence_map)
  : evidence_map_(evidence_map),
    info_evidence_header_(std::make_shared<InfoEvidenceHeader>()) {}
  ~EvidenceFactory() = default;

  void availableInfoFields(const VCFInfoRecordMap& vcf_info_map);
  [[nodiscard]] const VCFInfoRecordMap& availableInfoFields() const { return all_available_map_; }
  [[nodiscard]] InfoDataEvidence createVariantEvidence(std::string&& info);

private:

  // The evidence fields specified in the runtime XML file.
  const EvidenceInfoSet evidence_map_;
  // available info fields parsed from the VCF header.
  InfoSubscribedMap active_info_map_;
  // All available info fields.
  VCFInfoRecordMap all_available_map_;
  // The info header block
  std::shared_ptr<InfoEvidenceHeader> info_evidence_header_;

  std::unique_ptr<InfoDataBlock> parseSubscribed(std::string&& info);


};



} // namespace





#endif //KGL_VARIANT_FACTORY_VCF_EVIDENCE_H
