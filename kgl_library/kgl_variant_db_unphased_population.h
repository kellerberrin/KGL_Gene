//
// Created by kellerberrin on 13/08/18.
//

#ifndef KGL_VARIANT_DB_UNPHASED_POPULATION_H
#define KGL_VARIANT_DB_UNPHASED_POPULATION_H


#include "kgl_variant_db_unphased.h"

#include <mutex>
#include <functional>

namespace kellerberrin::genome {   //  organization::project


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// An internal parser variant object that holds variants until they can be phased.
// This object hold variants for a population.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////


using UnphasedGenomeMap = std::map<GenomeId_t, std::shared_ptr<UnphasedGenome>>;
class UnphasedPopulation {

public:

  explicit UnphasedPopulation(const PopulationId_t& population_id) : population_id_(population_id) {}
  UnphasedPopulation(const UnphasedPopulation&) = delete; // Use deep copy.
  virtual ~UnphasedPopulation() = default;

  UnphasedPopulation& operator=(const UnphasedPopulation&) = delete; // Use deep copy.

  // Use this to copy the object.
  [[nodiscard]] std::shared_ptr<UnphasedPopulation> deepCopy() const;

  // Create the genome variant if it does not exist.
  [[nodiscard]] std::optional<std::shared_ptr<UnphasedGenome>> getCreateGenome(const GenomeId_t& genome_id);

  [[nodiscard]] size_t variantCount() const;

  // Test if an equivalent variant already exists in the population.
  [[nodiscard]] bool variantExists(const std::shared_ptr<const Variant>& variant) const;

  void popStatistics() const; // output to logger

  [[nodiscard]] std::vector<GenomeId_t> genomeList() const;

  [[nodiscard]] std::shared_ptr<UnphasedPopulation> filterVariants(const VariantFilter& filter) const;

  [[nodiscard]] const UnphasedGenomeMap& getMap() const { return genome_map_; }

  void clear() { genome_map_.clear(); }

  // Generate phasing statistics (only valid with ploidy 2 variants).
  [[nodiscard]] bool genomePhasingStats( const GenomeId_t& genome_id,
                                         size_t& heterozygous,
                                         size_t& homozygous,
                                         size_t& singleheterozygous) const;

  [[nodiscard]] bool addGenome(const std::shared_ptr<UnphasedGenome>& genome);

  // Unconditionally add a variant to the population.
  [[nodiscard]] bool addVariant(const std::shared_ptr<const Variant>& variant_ptr);

  // The first bool is normal operation. The second bool is if a unique variant was added to the population.
  [[nodiscard]] bool addUniqueVariant(const std::shared_ptr<const Variant>& variant);

  [[nodiscard]] const PopulationId_t& populationId() const { return population_id_; }
  void setPopulationId(const PopulationId_t& population_id) { population_id_ = population_id; }
  // unconditionally merge (retains duplicates) genomes and variants into this population.
  [[nodiscard]] size_t mergePopulation(const std::shared_ptr<const UnphasedPopulation>& merge_population);
  // Validate returns a pair<size_t, size_t>. The first integer is the number of variants examined.
  // The second integer is the number variants that pass inspection by comparison to the reference genome.
  [[nodiscard]] std::pair<size_t, size_t> validate(const std::shared_ptr<const GenomeReference>& genome_db) const;
  // Unconditionally merge (retains duplicates) a variant genome into this population. Returns the new size of the population.
  [[nodiscard]] size_t mergeGenome(const std::shared_ptr<const UnphasedGenome>& genome);
  // Compress a population into a single genome. Done when generating aggregate variant statistics for a population.
  [[nodiscard]] std::shared_ptr<UnphasedGenome> compressPopulation() const;
  // Get the Info header, get the field header object from the first variant in the population.
  // Careful, this implicitly assumes that all variants in the population have the same DataMemoryBlock this only true
  // Of populations generated by a single VCF file.
  [[nodiscard]] std::optional<std::shared_ptr<const InfoEvidenceHeader>> getVCFInfoEvidenceHeader() const;
  // Processes all variants in the population with class Obj and Func = &Obj::objFunc(const shared_ptr<const Variant>&)
  template<class Obj, typename Func> bool processAll(Obj& object, Func objFunc) const;
  // Create a population of unique variants. All duplicate variants are removed.
  [[nodiscard]] std::shared_ptr<UnphasedPopulation> uniqueVariantPopulation() const;
  // Population set operations.
  // Important - set operations return populations containing unique variants only.
  // Duplicate variants are removed.
  // Returns a union of this population and the population supplied as an argument.
  // There are no duplicate variants in the union.
  [[nodiscard]] std::shared_ptr<UnphasedPopulation> setUnion(const std::shared_ptr<const UnphasedPopulation>& union_population) const;
  // Returns a population containing only the variants present in this population and the argument population.
  // The are no duplicate variants in the intersection.
  [[nodiscard]] std::shared_ptr<UnphasedPopulation> setIntersection(const std::shared_ptr<const UnphasedPopulation>& intersection_population) const;
  // Returns a population containing variants present is this population that are not in the argument population.
  // The are no duplicate variants in the complement.
  [[nodiscard]] std::shared_ptr<UnphasedPopulation> setComplement(const std::shared_ptr<const UnphasedPopulation>& complement_population) const;


private:

  UnphasedGenomeMap genome_map_;
  PopulationId_t population_id_;

};

// General purpose population processing template.
// Processes all variants in the population with class Obj and Func = &(bool Obj::objFunc(const std::shared_ptr<const Variant>))
template<class Obj, typename Func>
bool UnphasedPopulation::processAll(Obj& object, Func objFunc)  const {

  for (auto const& genome : getMap()) {

    for (auto const& contig : genome.second->getMap()) {

      for (auto const& variant_vector : contig.second->getMap()) {

        for (auto const& variant_ptr : variant_vector.second) {

          if (not (object.*objFunc)(variant_ptr)) {

            ExecEnv::log().error("UnphasedPopulation::processAll<Obj, Func>; Problem executing general purpose template function.");
            return false;

          }

        }

      }

    }

  }

  return true;

}




}   // end namespace

[[nodiscard]] std::ostream& operator<<(std::ostream& ostream, std::shared_ptr<const kellerberrin::genome::UnphasedPopulation> unphased_ptr);
[[nodiscard]] std::ostream& operator<<(std::ostream& ostream, const kellerberrin::genome::UnphasedPopulation& unphased);







#endif //KGL_VARIANT_DB_UNPHASED_POPULATION_H
