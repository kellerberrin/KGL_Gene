//
// Created by kellerberrin on 17/11/17.
//
#include "kgl_pfgenome_aux.h"
#include "kgl_phylogenetic_analysis.h"
#include "kgl_analysis_gene_sequence.h"
#include "kgl_sequence_complexity.h"
#include "kgl_mutation_variant_filter.h"
#include "kgl_io_gff_fasta.h"

namespace kgl = kellerberrin::genome;


bool kgl::GenomicMutation::writeMutantProteins(const std::string& fasta_file,
                                               const std::vector<std::pair<std::string, std::shared_ptr<AminoSequence>>>& amino_seq_vector) {

  std::vector<WriteFastaSequence> fasta_sequence_vec;

  for (auto const& amino_sequence : amino_seq_vector) {

    WriteFastaSequence fasta_sequence (amino_sequence.first, "", amino_sequence.second);
    fasta_sequence_vec.push_back(fasta_sequence);

  }

  return ParseFasta::writeFastaFile(fasta_file, fasta_sequence_vec);


}

bool kgl::GenomicMutation::writeMutantDNA(const std::string& fasta_file,
                                          const std::vector<std::pair<std::string, std::shared_ptr<DNA5SequenceLinear>>>& dna_seq_vector) {

  std::vector<WriteFastaSequence> fasta_sequence_vec;

  for (auto const& amino_sequence : dna_seq_vector) {

    WriteFastaSequence fasta_sequence(amino_sequence.first, "Generated by GenomicMutation::writeMutantDNA()", amino_sequence.second);
    fasta_sequence_vec.push_back(fasta_sequence);

  }

  return ParseFasta::writeFastaFile(fasta_file, fasta_sequence_vec);


}


bool kgl::GenomicMutation::readFastaProteins(const std::string& fasta_file,
                                             std::vector<std::pair<std::string, std::shared_ptr<AminoSequence>>>& amino_seq_vector) {


  std::vector<std::shared_ptr<AminoSequence>> mutant_sequence_vector;
  std::shared_ptr<AminoSequence> reference_sequence;

  std::vector<ReadFastaSequence> fasta_sequence_vec;
  if (ParseFasta::readFastaFile(fasta_file, fasta_sequence_vec)) {

    for (auto const& sequence: fasta_sequence_vec) {

      StringAminoAcid fasta_amino_string(sequence.fastaSequence()); // Converted from a std::string to an amino sequence.
      std::shared_ptr<AminoSequence> fasta_amino_seq_ptr(std::make_shared<AminoSequence>(std::move(fasta_amino_string)));
      std::pair<std::string, std::shared_ptr<AminoSequence>> insert_pair(sequence.fastaId(), fasta_amino_seq_ptr);
      amino_seq_vector.push_back(insert_pair);

    }

  } else {

    ExecEnv::log().warn("Unable read Fasta file: {}", fasta_file);
    return false;

  }

  return true;

}




bool kgl::GenomicMutation::compare5Prime(const ContigId_t& contig_id,
                                         const FeatureIdent_t& gene_id,
                                         const FeatureIdent_t& transcript_id,
                                         ContigSize_t region_size,
                                         const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                         const std::shared_ptr<const GenomeDB>& genome_db_ptr,
                                         DNA5SequenceCoding& reference_sequence,
                                         DNA5SequenceCoding& mutant_sequence) {

  // Get the contig_ref_ptr.
  std::optional<std::shared_ptr<const ContigReference>> contig_ref_opt = genome_ref_ptr->getContigSequence(contig_id);
  if (not contig_ref_opt) {

    ExecEnv::log().warn("GenomicMutation::compare5Prime, Could not find contig_ref_ptr: {} in genome database", contig_id);
    return false;

  }
  const auto& contig_ref_ptr = contig_ref_opt.value();

  // Get the coding sequence.
  auto transcript_opt = contig_ref_ptr->getTranscription(gene_id, transcript_id);
  if (not transcript_opt) {

    ExecEnv::log().warn("GenomicMutation::compare5Prime, Could not find a coding sequence for gene: {}, sequence: {}", gene_id, transcript_id);
    return false;

  }
  const auto& transcript_ptr = transcript_opt.value();
  const auto prime_5_region = transcript_ptr->prime5Region(region_size);

  ExecEnv::log().info("Analyzing the 5 Prime Region for Sequence {} at interval: {}",
                      transcript_ptr->getParent()->id(), prime_5_region.toString());

  auto contig_db_opt = genome_db_ptr->getContig(contig_id);
  if (not contig_db_opt) {

    ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
    return false;

  }
  const auto& contig_db_ptr = contig_db_opt.value();

  SequenceVariantFilter seq_variant_filter(contig_db_ptr, prime_5_region);

  // And mutate the sequence.
  AdjustedSequence adjusted_sequence;
  if (not adjusted_sequence.updateSequence(contig_ref_ptr, seq_variant_filter)) {

    ExecEnv::log().warn("Problem mutating region DNA sequence for contig_id id: {}, interval: {}",
                        contig_db_ptr->contigId(), seq_variant_filter.sequenceInterval().toString());
    return false;

  }

  auto dual_seq_opt = adjusted_sequence.moveSequenceClear();
  if (not dual_seq_opt) {

    ExecEnv::log().error("Unexpected error mutating Genome: {}, Contig: {}, Interval: {}",
                         genome_db_ptr->genomeId(), contig_id, prime_5_region.toString());
    return false;

  }
  const auto& [ref_sequence, mod_sequence] = dual_seq_opt.value();

  reference_sequence = ref_sequence.codingSequence(transcript_ptr->strand());
  mutant_sequence = mod_sequence.codingSequence(transcript_ptr->strand());

  return true;

}


bool kgl::GenomicMutation::compare3Prime(const ContigId_t& contig_id,
                                         const FeatureIdent_t& gene_id,
                                         const FeatureIdent_t& transcript_id,
                                         ContigSize_t region_size,
                                         const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                         const std::shared_ptr<const GenomeDB>& genome_db_ptr,
                                         DNA5SequenceCoding& reference_sequence,
                                         DNA5SequenceCoding& mutant_sequence) {

  // Get the contig_ref_ptr.
  auto contig_ref_opt = genome_ref_ptr->getContigSequence(contig_id);
  if (not contig_ref_opt) {

    ExecEnv::log().warn("Could not find contig_ref_ptr: {} in genome database", contig_id);
    return false;

  }
  const auto& contig_ref_ptr = contig_ref_opt.value();

  // Get the coding sequence.
  auto transcript_opt = contig_ref_ptr->getTranscription(gene_id, transcript_id);
  if (not transcript_opt) {

    ExecEnv::log().warn("Could not find a coding sequence for gene: {}, sequence: {}", gene_id, transcript_id);
    return false;

  }
  const auto& transcript_ptr = transcript_opt.value();
  const auto prime_3_interval = transcript_ptr->prime3Region(region_size);

  ExecEnv::log().info("Analyzing the 3 Prime Region for Sequence {} at interval: {}",
                      transcript_ptr->getParent()->id(), prime_3_interval.toString());

  auto contig_db_opt = genome_db_ptr->getContig(contig_id);
  if (not contig_db_opt) {

    ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
    return false;

  }
  const auto& contig_db_ptr = contig_db_opt.value();

  SequenceVariantFilter seq_variant_filter(contig_db_ptr, prime_3_interval);

  // And mutate the sequence.
  AdjustedSequence adjusted_sequence;
  if (not adjusted_sequence.updateSequence(contig_ref_ptr, seq_variant_filter)) {

    ExecEnv::log().warn("Problem mutating region DNA sequence for contig_id id: {}, interval: {}",
                        contig_db_ptr->contigId(), seq_variant_filter.sequenceInterval().toString());
    return false;

  }

  auto dual_seq_opt = adjusted_sequence.moveSequenceClear();
  if (not dual_seq_opt) {

    ExecEnv::log().error("Unexpected error mutating Genome: {}, Contig: {}, Interval: {}",
                         genome_db_ptr->genomeId(), contig_id, prime_3_interval.toString());
    return false;

  }
  const auto& [ref_sequence, mod_sequence] = dual_seq_opt.value();

  reference_sequence = ref_sequence.codingSequence(transcript_ptr->strand());
  mutant_sequence = mod_sequence.codingSequence(transcript_ptr->strand());

  return true;

}


bool kgl::GenomicMutation::outputRegionCSV(const std::string &file_name,
                                           LinearDistanceMetric linear_dna_distance_metric,
                                           CodingDistanceMetric coding_dna_distance_metric,
                                           AminoDistanceMetric amino_distance_metric,
                                           const std::shared_ptr<const GenomeReference>& genome_db,
                                           const std::shared_ptr<const PopulationDB>& pop_variant_ptr) {

  const char CSV_delimiter = ',';
  // open the file.
  std::fstream out_file(file_name, std::fstream::out | std::fstream::app);
  if (!out_file) {

    ExecEnv::log().error("Cannot open output CSV file: {}", file_name);
    return false;

  }

  out_file << GenomicSequence::outputRegionHeader(CSV_delimiter) << CSV_delimiter;
  out_file << outputRegionHeader(CSV_delimiter) << '\n';

  for(auto const& [genome_id, genome_variant_ptr] : pop_variant_ptr->getMap()) {

    ExecEnv::log().info("oProcessing genome: {}", genome_id);
    size_t sequence_count = 0;

    for (auto const& [contig_id, contig_ptr] : genome_db->getMap()) {

      std::shared_ptr<const TranscriptionSequence> previous_seq_ptr = nullptr;

      for (auto const& [gene_offset, gene_ptr] : contig_ptr->getGeneMap()) {

        auto coding_seq_ptr = kgl::GeneFeature::getTranscriptionSequences(gene_ptr);
        for (auto const& [sequence_id, sequence_ptr] : coding_seq_ptr->getMap()) {

          ContigSize_t front_porch_size;
          ContigOffset_t front_porch_offset;
          if (not previous_seq_ptr) {

            front_porch_offset = 0;
            front_porch_size = sequence_ptr->start();

          } else {

            front_porch_offset = previous_seq_ptr->end();
            if (front_porch_offset <= sequence_ptr->start()) {

              front_porch_size = sequence_ptr->start() - front_porch_offset;

            } else {

              ExecEnv::log().info("Sequence: {} end offset: {} overlaps sequence: {} begin offset: {}",
                                  previous_seq_ptr->getParent()->id(),
                                  previous_seq_ptr->end(),
                                  sequence_ptr->getParent()->id(),
                                  sequence_ptr->start());

              front_porch_size = 0;

            }

          }

          out_file << GenomicSequence::outputGenomeRegion(CSV_delimiter,
                                                          linear_dna_distance_metric,
                                                          contig_id,
                                                          front_porch_offset,
                                                          front_porch_size,
                                                          genome_variant_ptr,
                                                          genome_db);
          out_file << CSV_delimiter;
          out_file << outputSequence(CSV_delimiter,
                                     coding_dna_distance_metric,
                                     amino_distance_metric,
                                     sequence_ptr,
                                     genome_db,
                                     genome_variant_ptr);
          out_file << '\n';
          ++sequence_count;
          previous_seq_ptr = sequence_ptr;

        }

      }

    }

    ExecEnv::log().info("Genome: {} mutated: {} sequences.", genome_id, sequence_count);

  }

  return out_file.good();

}


bool kgl::GenomicMutation::outputDNASequenceCSV(const std::string &file_name,
                                                SequenceAnalysisType analysis_type,
                                                CodingDistanceMetric dna_distance_metric,
                                                const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                                const std::shared_ptr<const PopulationDB>& pop_variant_ptr) {

  const char CSV_delimiter = ',';
  // open the file.
  std::ofstream out_file(file_name);
  if (not out_file.good()) {

    ExecEnv::log().error("Cannot open output CSV file: {}", file_name);
    return false;

  }

  out_file << outputSequenceHeader(CSV_delimiter, pop_variant_ptr) << '\n';

  for (const auto& [contig_id, contig_ref_ptr] : genome_ref_ptr->getMap()) {

    ExecEnv::log().info("Processing contig_ref_ptr: {}", contig_id);

    size_t sequence_count = 0;

    for (const auto& [gene, gene_ptr] : contig_ref_ptr->getGeneMap()) {

      auto transcript_array_ptr = kgl::GeneFeature::getTranscriptionSequences(gene_ptr);
      for (const auto& [transcript_id, transcript_ptr] : transcript_array_ptr->getMap()) {


        out_file << contig_ref_ptr->contigSize() << CSV_delimiter;
        out_file << gene_ptr->id() << CSV_delimiter;
        out_file << transcript_id << CSV_delimiter;
        out_file << transcript_ptr->start() << CSV_delimiter;
        out_file << transcript_ptr->codingNucleotides() << CSV_delimiter;

        // Valid ORF
        auto coding_dna_opt = contig_ref_ptr->codingSequence(transcript_ptr);
        if (coding_dna_opt) {

          auto sequence_validity = contig_ref_ptr->checkValidCodingSequence(coding_dna_opt.value());
          bool valid_sequence = TranscriptionSequence::checkValidProtein(sequence_validity);
          out_file << (valid_sequence ? "1" : "0") << CSV_delimiter;

        } else {

          out_file << "0" << CSV_delimiter;
          return false;

        }
        const auto& coding_dna_sequence = coding_dna_opt.value();

        const std::vector<std::pair<CodingDNA5::Alphabet, size_t>> count_vector = coding_dna_sequence.countSymbols();
        out_file << SequenceComplexity::alphabetEntropy<CodingDNA5>(coding_dna_sequence, count_vector) << CSV_delimiter;
        out_file << SequenceComplexity::complexityLempelZiv(coding_dna_sequence) << CSV_delimiter;
        out_file << SequenceComplexity::relativeCpGIslands(coding_dna_sequence) << CSV_delimiter;  // GC count.
        for (auto const& count : count_vector) {

          out_file << static_cast<double>(count.second) * 100.0 / static_cast<double>(coding_dna_sequence.length()) << CSV_delimiter;

        }

        out_file << CSV_delimiter;
        out_file << CSV_delimiter;
        std::vector<std::string> description_vec;
        if (not gene_ptr->getAttributes().getDescription(description_vec)) {

          ExecEnv::log().error("Cannot get description vector for Gene: {}", gene_ptr->id());

        }
        std::string description;
        for (const auto &desc : description_vec) {

          description += desc;
          description += ";";

        }

        out_file << "\"" << description << "\"" << CSV_delimiter;
        out_file << CSV_delimiter;


        for(const auto& [genome_id, genome_db_ptr] : pop_variant_ptr->getMap()) {

          auto contig_db_opt = genome_db_ptr->getContig(contig_id);
          if (not contig_db_opt) {

            ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
            return false;

          }
          const auto& contig_db_ptr = contig_db_opt.value();


          SequenceTranscript modified_transcript(contig_db_ptr, transcript_ptr);
          auto reference_sequence_opt = modified_transcript.getOriginalCoding();
          auto mutant_sequence_opt = modified_transcript.getModifiedCoding();

          if (modified_transcript.sequenceStatus() and reference_sequence_opt and mutant_sequence_opt) {

            auto const& reference_sequence = reference_sequence_opt.value();
            auto const& mutant_sequence = mutant_sequence_opt.value();

            switch(analysis_type) {

              case SequenceAnalysisType::DNA: {

                CompareDistance_t DNA_distance;
                DNA_distance = dna_distance_metric(reference_sequence, mutant_sequence);
                out_file << DNA_distance << CSV_delimiter;

              }
                break;

              case SequenceAnalysisType::ENTROPY:
                out_file << SequenceComplexity::alphabetEntropy<CodingDNA5>(mutant_sequence, mutant_sequence.countSymbols()) << CSV_delimiter;
                break;

              case SequenceAnalysisType::LEMPEL_ZIV:
                out_file << SequenceComplexity::complexityLempelZiv(mutant_sequence) << CSV_delimiter;
                break;

              default:
              case SequenceAnalysisType::SIZE:
                out_file << mutant_sequence.length() << CSV_delimiter;
                break;

            }


          } else {

            ExecEnv::log().error("Error Processing transcript_id: {}", transcript_id);
            return false;

          }

          ++sequence_count;

        }

        out_file << '\n';

      }

    }

    ExecEnv::log().info("Mutated: {} sequences.", sequence_count);

  }

  return out_file.good();

}


bool kgl::GenomicMutation::outputAminoSequenceCSV(const std::string &file_name,
                                                  AminoDistanceMetric amino_distance_metric,
                                                  const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                                  const std::shared_ptr<const PopulationDB>& pop_variant_ptr) {

  const char CSV_delimiter = ',';
  // open the file.
  std::ofstream out_file(file_name);
  if (not out_file.good()) {

    ExecEnv::log().error("Cannot open output CSV file: {}", file_name);
    return false;

  }

  out_file << outputSequenceHeader(CSV_delimiter, pop_variant_ptr) << '\n';

  for (auto const& [contig_id, contig_ref_ptr] : genome_ref_ptr->getMap()) {

    ExecEnv::log().info("Processing contig_ref_ptr: {}", contig_id);

    size_t sequence_count = 0;

    for (auto const& [gene_offset, gene_ptr] : contig_ref_ptr->getGeneMap()) {

      auto coding_seq_ptr = GeneFeature::getTranscriptionSequences(gene_ptr);
      for (auto const& [transcript_id, transcript_ptr] : coding_seq_ptr->getMap()) {


        out_file << contig_ref_ptr->contigSize() << CSV_delimiter;
        out_file << gene_ptr->id() << CSV_delimiter;
        out_file << transcript_id << CSV_delimiter;
        out_file << transcript_ptr->start() << CSV_delimiter;
        out_file << transcript_ptr->codingNucleotides() << CSV_delimiter;

        auto coding_dna_opt = gene_ptr->contig_ref_ptr()->codingSequence(transcript_ptr);
        if (coding_dna_opt) {

          DNA5SequenceCoding& verify_coding_sequence = coding_dna_opt.value();
          auto sequence_validity = contig_ref_ptr->checkValidCodingSequence(verify_coding_sequence);
          bool valid_sequence = TranscriptionSequence::checkValidProtein(sequence_validity);
          out_file << (valid_sequence ? "1" : "0") << CSV_delimiter;

        } else {

          out_file << "0" << CSV_delimiter;
          return false;

        }
        DNA5SequenceCoding& coding_dna_sequence = coding_dna_opt.value();

        AminoSequence amino_reference  = contig_ref_ptr->getAminoSequence(coding_dna_sequence);
        out_file << SequenceComplexity::alphabetEntropy<AminoAcid>(amino_reference, amino_reference.countSymbols()) << CSV_delimiter;
        out_file << SequenceComplexity::complexityLempelZiv(coding_dna_sequence) << CSV_delimiter;
        out_file << SequenceComplexity::relativeCpGIslands(coding_dna_sequence) << CSV_delimiter;  // GC count.
        for (auto const& count : coding_dna_sequence.countSymbols()) {

          out_file << (static_cast<double>(count.second) * 100.0) / static_cast<double>(coding_dna_sequence.length()) << CSV_delimiter;

        }


        out_file << CSV_delimiter;
        out_file << CSV_delimiter;
        std::vector<std::string> description_vec;

        if (not gene_ptr->getAttributes().getDescription(description_vec)) {

          ExecEnv::log().error("Cannot get description vector for Gene: {}", gene_ptr->id());

        }

        std::string description;
        for (const auto &desc : description_vec) {

          description += desc;
          description += ";";

        }

        out_file << "\"" << description << "\"" << CSV_delimiter;
        out_file << CSV_delimiter;

        for( auto [genome, genome_db_ptr] : pop_variant_ptr->getMap()) {

          auto contig_db_opt = genome_db_ptr->getContig(contig_id);
          if (not contig_db_opt) {

            ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
            return false;

          }
          auto& contig_db_ptr = contig_db_opt.value();
          OpenRightUnsigned region_interval(transcript_ptr->start(), transcript_ptr->end());
          SequenceVariantFilter seq_variant_filter(contig_db_ptr, region_interval);

          SequenceTranscript modified_transcript(contig_db_ptr, transcript_ptr);

          auto reference_sequence_opt = modified_transcript.getOriginalCoding();
          auto mutant_sequence_opt = modified_transcript.getModifiedCoding();

          if (modified_transcript.sequenceStatus() and reference_sequence_opt and mutant_sequence_opt) {

            auto amino_reference_seq = contig_ref_ptr->getAminoSequence(reference_sequence_opt.value());
            auto amino_mutant = contig_ref_ptr->getAminoSequence(mutant_sequence_opt.value());

            switch (contig_ref_ptr->checkValidProteinSequence(amino_mutant)) {

              case CodingSequenceValidity::VALID_PROTEIN: {

                CompareDistance_t amino_distance = amino_distance_metric(amino_reference_seq, amino_mutant);
                out_file << amino_distance << CSV_delimiter;

              }
                break;

              case CodingSequenceValidity::NO_START_CODON:
                out_file << -1 << CSV_delimiter;
                break;

              case CodingSequenceValidity::NONSENSE_MUTATION: {

                auto [seq_validity_code, seq_validity_size] = contig_ref_ptr->proteinSequenceSize(amino_mutant);
                // +1 to include the stop codon.
                seq_validity_size += 1;
                double proportion = (static_cast<double>(seq_validity_size) * -100.0) / static_cast<double>(amino_reference_seq.length());
                out_file << proportion << CSV_delimiter;

              }
                break;

              case CodingSequenceValidity::NO_STOP_CODON:
                out_file << -3 << CSV_delimiter;
                break;

              default:
                ExecEnv::log().error("Undefined sequence protein sequence type: {}", transcript_id);
                return false;

            }

          } else {

            ExecEnv::log().error("Error Processing sequence: {}", transcript_id);
            return false;

          }

          ++sequence_count;

        }

        out_file << '\n';

      }

    }

    ExecEnv::log().info("Mutated: {} sequences.", sequence_count);

  }

  return out_file.good();

}



std::string kgl::GenomicMutation::outputSequenceHeader(char delimiter,
                                                       const std::shared_ptr<const PopulationDB>& pop_variant_ptr) {

  std::stringstream ss;

  ss << "Contig" << delimiter;
  ss << "Gene" << delimiter;
  ss << "Sequence" << delimiter;
  ss << "Offset" << delimiter;
  ss << "DNALength" << delimiter;
  ss << "ValidORF" << delimiter;
  ss << "Entropy" << delimiter;
  ss << "LempelZiv" << delimiter;
  ss << "CpG" << delimiter;
  ss << "A_prop" << delimiter;
  ss << "C_prop" << delimiter;
  ss << "G_prop" << delimiter;
  ss << "T_prop" << delimiter;
  ss << "Symbolic" << delimiter;
  ss << "AltSymbolic" << delimiter;
  ss << "Description" << delimiter;
  ss << "GO_Records" << delimiter;


  for (auto genome : pop_variant_ptr->getMap()) {

    ss << genome.first << delimiter;

  }

  return ss.str();

}


bool kgl::GenomicMutation::outputAminoMutationCSV(const std::string &file_name,
                                                  const ContigId_t& contig_id,
                                                  const FeatureIdent_t& gene_id,
                                                  const FeatureIdent_t& transcript_id,
                                                  const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                                  const std::shared_ptr<const PopulationDB>& pop_variant_ptr) {

  const char CSV_delimiter = ',';
  // open the file.
  std::fstream out_file(file_name, std::fstream::out);
  if (!out_file) {

    ExecEnv::log().error("Cannot open output CSV file (--outCSVFile): {}", file_name);
    return false;

  }

  for(const auto& [genome_id, genome_db_ptr] : pop_variant_ptr->getMap()) {

    ExecEnv::log().info("Processing genome_id: {}", genome_id);
    size_t sequence_count = 0;

    sequence_count++;
    OffsetVariantMap variant_map;

    // Get the contig_ref_ptr.
    auto contig_ref_opt = genome_ref_ptr->getContigSequence(contig_id);
    if (not contig_ref_opt) {

      ExecEnv::log().warn("Could not find contig_ref_ptr: {} in genome_id database", contig_id);
      return false;

    }
    auto& contig_ref_ptr = contig_ref_opt.value();

    // Get the coding sequence.
    auto transcript_opt = contig_ref_ptr->getTranscription(gene_id, transcript_id);
    if (not transcript_opt) {

      ExecEnv::log().warn("Could not find a coding sequence for gene: {}, sequence: {}", gene_id, transcript_id);
      return false;

    }
    auto& transcript_ptr = transcript_opt.value();

    auto contig_db_opt = genome_db_ptr->getContig(contig_id);
    if (not contig_db_opt) {

      ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
      return false;

    }
    auto& contig_db_ptr = contig_db_opt.value();
    OpenRightUnsigned region_interval(transcript_ptr->interval());
    SequenceVariantFilter seq_variant_filter(contig_db_ptr, region_interval);

    SequenceTranscript modified_transcript(contig_db_ptr, transcript_ptr);

    auto reference_sequence_opt = modified_transcript.getOriginalCoding();
    auto mutant_sequence_opt = modified_transcript.getModifiedCoding();

    if (modified_transcript.sequenceStatus() and reference_sequence_opt and mutant_sequence_opt) {

      auto amino_reference_seq = contig_ref_ptr->getAminoSequence(reference_sequence_opt.value());
      auto amino_mutant = contig_ref_ptr->getAminoSequence(mutant_sequence_opt.value());


      EditVector edit_vector;
      SequenceComparison().editDNAItems(amino_reference_seq.getSequenceAsString(),
                                        amino_mutant.getSequenceAsString(),
                                        edit_vector);

      for (auto edit_item : edit_vector) {

        std::stringstream ss;
        ss << genome_id << CSV_delimiter;
        ss << gene_id << CSV_delimiter;
        ss << transcript_id << CSV_delimiter;
        ss << edit_item.reference_char << CSV_delimiter;
        ss << edit_item.reference_offset << CSV_delimiter;
        ss << edit_item.mutant_char << '\n';
        out_file << ss.str();

      } // for mutant

    } // if mutation

    ExecEnv::log().info("Genome: {} mutated: {} sequences.", genome_id, sequence_count);

  } // for genome

  return out_file.good();

}



bool kgl::GenomicMutation::outputDNAMutationCSV(const std::string &file_name,
                                                const ContigId_t& contig_id,
                                                const FeatureIdent_t& gene_id,
                                                const FeatureIdent_t& transcript_id,
                                                const std::shared_ptr<const GenomeReference>& genome_ref_ptr,
                                                const std::shared_ptr<const PopulationDB>& pop_variant_ptr,
                                                const PfGenomeAuxData& aux_Pf3k_data) {

  const char CSV_delimiter = ',';
  // open the file.
  std::fstream out_file(file_name, std::fstream::out);
  if (!out_file) {

    ExecEnv::log().error("Cannot open output CSV file: {}", file_name);
    return false;

  }

  std::fstream variant_file(file_name + ".variant", std::fstream::out);
  if (!out_file) {

    ExecEnv::log().error("Cannot open output Variant file: {}", file_name + ".variant");
    return false;

  }

  // Get the contig_ref_ptr.
  std::optional<std::shared_ptr<const ContigReference>> contig_ref_opt = genome_ref_ptr->getContigSequence(contig_id);
  if (not contig_ref_opt) {

    ExecEnv::log().error("Could not find contig_ref_ptr: {} in genome database", contig_id);
    return false;

  }
  const auto& contig_ref_ptr = contig_ref_opt.value();

  using SNPMap = std::map<std::string, MutationItem>;
  SNPMap master_SNP_List;
  struct GenomeMap {

    std::string genome;
    std::string location_date;
    SNPMap snp_map;

  };

  std::vector<GenomeMap> genome_vector;
  for( auto const& [genome, genome_db_ptr] : pop_variant_ptr->getMap()) {

    ExecEnv::log().info("Processing genome: {}", genome);
    size_t sequence_count = 0;

    sequence_count++;

    // Get the coding sequence.
    auto transcript_opt = contig_ref_ptr->getTranscription(gene_id, transcript_id);
    if (transcript_opt) {

      ExecEnv::log().warn("Could not find a coding sequence for gene: {}, sequence: {}", gene_id, transcript_id);
      return false;

    }
    const auto& transcript_ptr = transcript_opt.value();

    auto contig_db_opt = genome_db_ptr->getContig(contig_id);
    if (not contig_db_opt) {

      ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
      return false;

    }
    const auto& contig_db_ptr = contig_db_opt.value();

    SequenceTranscript modified_transcript(contig_db_ptr, transcript_ptr);
    auto reference_sequence_opt = modified_transcript.getOriginalCoding();
    auto mutant_sequence_opt = modified_transcript.getModifiedCoding();

    if (modified_transcript.sequenceStatus() and reference_sequence_opt and mutant_sequence_opt) {

      auto const& reference_sequence = reference_sequence_opt.value();
      auto const& mutant_sequence = mutant_sequence_opt.value();

      EditVector edit_vector;
      SequenceComparison().editDNAItems(reference_sequence.getSequenceAsString(),
                                        mutant_sequence.getSequenceAsString(),
                                        edit_vector);

      MutationEditVector mutation_edit_vector;
      MutationItem mutation_item;
      for (auto edit_item : edit_vector) {

        ContigOffset_t codon_index = static_cast<size_t>(edit_item.reference_offset / 3);

        const Codon mutant_codon(mutant_sequence, codon_index);
        const Codon ref_codon(reference_sequence, codon_index);

        mutation_item.DNA_mutation = edit_item;
        mutation_item.reference_codon = ref_codon.getSequenceAsString();
        mutation_item.mutation_codon = mutant_codon.getSequenceAsString();

        mutation_item.amino_mutation.reference_char = AminoAcid::convertToChar(contig_ref_ptr->getAminoAcid(ref_codon));
        mutation_item.amino_mutation.reference_offset = codon_index;
        mutation_item.amino_mutation.mutant_char = AminoAcid::convertToChar(contig_ref_ptr->getAminoAcid(mutant_codon));
        mutation_item.contig_id = contig_ref_ptr->contigId();
        ContigOffset_t contig_offset;
        mutation_item.contig_offset = contig_offset;
        mutation_edit_vector.mutation_vector.push_back(mutation_item);

      }

      if (not mutation_edit_vector.hasIndel()) { // Only SNPs.

        GenomeMap genome_map;

        genome_map.genome = genome;
        if (aux_Pf3k_data.isFieldSample(genome)) {

          genome_map.location_date = aux_Pf3k_data.locationDate(genome);

        } else {

          genome_map.location_date = genome;

        }

        for (auto edit_item : mutation_edit_vector.mutation_vector) {

          master_SNP_List[edit_item.mapKey()] = edit_item;
          genome_map.snp_map[edit_item.mapKey()] = edit_item;
          ExecEnv::log().info("Edit Item Contig: {}, Contig Offset:{}, DNA Offset:{}",
                              edit_item.contig_id, edit_item.contig_offset, master_SNP_List[edit_item.mapKey()].DNA_mutation.reference_offset);

        }

        genome_vector.push_back(genome_map);

      }

    } // if mutation

    ExecEnv::log().info("Genome: {} mutated: {} sequences.", genome, sequence_count);

  } // for genome

// Write file header.

  out_file << "Genome" << CSV_delimiter << "LocationDate" << CSV_delimiter;

  for (auto DNA_Item : master_SNP_List) {

    out_file << DNA_Item.second.contig_id << " "
             << DNA_Item.second.contig_offset << " "
             << DNA_Item.second.DNA_mutation.reference_char
             << DNA_Item.second.DNA_mutation.reference_offset
             << DNA_Item.second.DNA_mutation.mutant_char
             << " " << DNA_Item.second.reference_codon << "-" << DNA_Item.second.mutation_codon
             << " " << DNA_Item.second.amino_mutation.reference_char
             << DNA_Item.second.amino_mutation.reference_offset
             << DNA_Item.second.amino_mutation.mutant_char << CSV_delimiter;

  }
  out_file << std::endl;

// Write data.

  for (auto genome_item : genome_vector) {

    out_file << genome_item.genome << CSV_delimiter << genome_item.location_date << CSV_delimiter;

    for (auto DNA_Item : master_SNP_List) {

      auto result = genome_item.snp_map.find(DNA_Item.first);
      if (result == genome_item.snp_map.end()) {

        out_file << 0 << CSV_delimiter;

      } else {

        out_file << 1 << CSV_delimiter;

      }

    }

    out_file << std::endl;

  }

  return out_file.good();

}



std::string kgl::GenomicMutation::outputRegionHeader(char delimiter) {

  std::stringstream ss;

  ss << "Genome" << delimiter;
  ss << "Contig" << delimiter;
  ss << "ContigLength" << delimiter;
  ss << "Sequence" << delimiter;
  ss << "ContigOffset" << delimiter;
  ss << "DNASize" << delimiter;
  ss << "CpG" << delimiter;
  ss << "A_prop" << delimiter;
  ss << "C_prop" << delimiter;
  ss << "G_prop" << delimiter;
  ss << "T_prop" << delimiter;
  ss << "N_prop" << delimiter;
  ss << "Error" << delimiter;
  ss << "ValidReference" << delimiter;
  ss << "AllPaths" << delimiter;
  ss << "ValidPaths" << delimiter;
  ss << "Score" << delimiter;
  ss << "Strand" << delimiter;
  ss << "DNAScore" << delimiter;
  ss << "Symbolic" << delimiter;
  ss << "AltSymbolic" << delimiter;
  ss << "Description";

  return ss.str();

}



std::string kgl::GenomicMutation::outputSequence(char delimiter,
                                                 CodingDistanceMetric dna_distance_metric,
                                                 AminoDistanceMetric amino_distance_metric,
                                                 const std::shared_ptr<const TranscriptionSequence>& transcript_ptr,
                                                 const std::shared_ptr<const GenomeReference>&,
                                                 const std::shared_ptr<const GenomeDB>& genome_db_ptr) {

  std::string genome_id = genome_db_ptr->genomeId();
  std::shared_ptr<const ContigReference> contig_ptr = transcript_ptr->getGene()->contig_ref_ptr();
  std::string contig_id = contig_ptr->contigId();
  std::string gene_id = transcript_ptr->getGene()->id();
  std::string transcript_id = transcript_ptr->getParent()->id();
  ContigOffset_t sequence_offset = transcript_ptr->start();
  char strand = static_cast<char>(transcript_ptr->strand());

  bool error_flag = true;
  size_t mutant_paths = 0;
  size_t valid_paths = 0;
  double average_score = 0;
  double average_DNA_score = 0;
  bool valid_reference = false;

  auto contig_db_opt = genome_db_ptr->getContig(contig_id);
  if (not contig_db_opt) {

    ExecEnv::log().warn("Contig: {} not found for Genome: {}", contig_id, genome_db_ptr->genomeId());
    return "<error>";

  }
  auto& contig_db_ptr = contig_db_opt.value();

  SequenceTranscript modified_transcript(contig_db_ptr, transcript_ptr);

  auto reference_sequence_opt = modified_transcript.getOriginalCoding();
  auto mutant_sequence_opt = modified_transcript.getModifiedCoding();

  if (modified_transcript.sequenceStatus() and reference_sequence_opt and mutant_sequence_opt) {

    auto const& reference_sequence = reference_sequence_opt.value();
    auto const& mutant_sequence = mutant_sequence_opt.value();

    CompareDistance_t DNA_distance;
    DNA_distance = dna_distance_metric(reference_sequence, mutant_sequence);
    average_DNA_score += static_cast<double>(DNA_distance);

    auto amino_reference_seq = contig_ptr->getAminoSequence(reference_sequence);
    auto amino_mutant = contig_ptr->getAminoSequence(mutant_sequence);

    error_flag = false;
    auto reference_validity = contig_ptr->checkValidProteinSequence(amino_reference_seq) ;
    valid_reference = TranscriptionSequence::checkValidProtein(reference_validity);

    CompareDistance_t amino_distance = amino_distance_metric(amino_reference_seq, amino_mutant);
    auto sequence_validity = contig_ptr->checkValidProteinSequence(amino_mutant) ;
    bool valid_sequence = TranscriptionSequence::checkValidProtein(sequence_validity);
    if (valid_sequence) {

      average_score += static_cast<double>(amino_distance);
      ++valid_paths;

    }
    ++mutant_paths;

    if (valid_paths > 0) {

      average_score = average_score / static_cast<double>(valid_paths);

    } else {

      average_score = 0;

    }


  } else {

    ExecEnv::log().error("Problem mutating contig_ref_ptr: {}, sequence: {}", contig_ptr->contigId(), transcript_id);

  }

  if (modified_transcript.sequenceStatus() and reference_sequence_opt) {

    auto const &reference_sequence = reference_sequence_opt.value();

    std::stringstream ss;

    ss << genome_id << delimiter;
    ss << contig_ptr->contigId() << delimiter;
    ss << transcript_id << delimiter;
    ss << contig_ptr->sequence().length() << delimiter;
    ss << sequence_offset << delimiter;
    ss << transcript_ptr->codingNucleotides() << delimiter;
    ss << SequenceComplexity::relativeCpGIslands(reference_sequence) << delimiter;  // GC count.
    for (auto const &count: reference_sequence.countSymbols()) {

      ss << (static_cast<double>(count.second) * 100.0) / static_cast<double>(reference_sequence.length()) << delimiter;

    }
    ss << error_flag << delimiter;
    ss << valid_reference << delimiter;
    ss << mutant_paths << delimiter;
    ss << valid_paths << delimiter;
    ss << average_score << delimiter;
    ss << strand << delimiter;
    ss << average_DNA_score << delimiter;


    ss << "<NULL>" << delimiter;
    ss << "<NULL>" << delimiter;
    std::vector<std::string> description_vec;
    if (not transcript_ptr->getGene()->getAttributes().getDescription(description_vec)) {

      ExecEnv::log().error("Cannot get description vector for Gene: {}", transcript_ptr->getGene()->id());

    }
    for (const auto &description: description_vec) {

      ss << "\"" << description << "\"";

    }

    return ss.str();

  }

  return "Error";

}

