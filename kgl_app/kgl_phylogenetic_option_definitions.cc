//
// Created by kellerberrin on 29/08/18.
//

#include "kgl_phylogenetic_option.h"
#include "kgl_exec_env.h"
#include <fstream>
#include <sstream>


namespace kgl = kellerberrin::genome;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Pre-defines all the valid options in the option file.
// All valid options must be defined here.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


kgl::PredefinedOptionType kgl::RuntimeOptions::defined_options_[] = {

{ MIXTURE_FILE_, OptionOptional::OPTIONAL, OptionArrayType::SINGULAR, OptionArgumentType::FILE_NAME, "mixture.txt",
R"("The mixture file was generated by Zhu, Almagro-Garcia and McVean using Deploid and describes
      the mixture status (complexity of infection) of the Pf3k samples. Only use this option when processing Pf3k samples.")"},

{ VCF_PLOIDY_, OptionOptional::OPTIONAL, OptionArrayType::SINGULAR, OptionArgumentType::INTEGER, "2",
R"("The ploidy of any input VCF files (this need not be the ploidy of the organism).")"},

};



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Functions that require the complete definition of the defined_options_ array (defined above)
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool kgl::RuntimeOptions::getDefinedOption(const RuntimeOptionTag& option, PredefinedOptionType& defined_option) {

  for (auto def_option : defined_options_) {

    if (def_option.name == option) {

      defined_option = def_option;
      return true;
    }

  }

  return false;

}


void kgl::RuntimeOptions::printHelp(std::ostream& stream) {

  stream << "Valid KGL Program Options Defined for the Options File" << '\n';
  stream << "======================================================" << '\n';

  for (auto option : defined_options_) {

    stream << '\n';
    stream << "OPTION: " << option.name << '\n';
    stream << "Required/Optional: ";
    stream << (option.optional == OptionOptional::REQUIRED ? "Required" : "Optional");
    stream << '\n';
    stream << "Option Array Type: ";
    switch(option.option_array_type) {

      case OptionArrayType::ARRAY:
        stream << "Array (1..n arguments)";
        break;

      case OptionArrayType::SINGULAR:
        stream << "Singular (1 argument)";
        break;

      case OptionArrayType::FLAG:
        stream << "Flag (no arguments)";
        break;

    }
    stream << '\n';
    stream << "OptionArgumentType: ";
    switch(option.option_arument_type) {

      case OptionArgumentType::FILE_NAME:
        stream << "FileName";
        break;

      case OptionArgumentType::STRING:
        stream << "String";
        break;

      case OptionArgumentType::INTEGER:
        stream << "Integer";
        break;

      case OptionArgumentType::FLOAT:
        stream << "Float";
        break;

    }
    stream << '\n';
    stream << "Description: ";
    stream << option.option_description << "\n\n";

  }

}


bool kgl::RuntimeOptions::checkRequiredOptions() {


  for (auto def_option : defined_options_) {

    if (def_option.optional == OptionOptional::REQUIRED) {

      auto result = runtime_option_map_.find(def_option.name);

      if (result == runtime_option_map_.end()) {

        ExecEnv::log().error("RuntimeOptions::checkRequiredOptions; Required option: {} not found in option file.", def_option.name);
        std::stringstream ss;
        printHelp(ss);
        ExecEnv::log().info("{}", ss.str());
        return false;

      }

    }

  }

  return true;

}


