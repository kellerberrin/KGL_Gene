//
// Created by kellerberrin on 28/08/18.
//

#include "kgl_phylogenetic_option.h"
#include "kgl_exec_env.h"
#include <boost/tokenizer.hpp>
#include <boost/algorithm/string.hpp>
#include <fstream>
#include <sstream>


namespace kgl = kellerberrin::genome;
namespace bt = boost;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Pre-defines all the valid options in the option file.
// All valid options must be defined here.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


kgl::PredefinedOptionType kgl::RuntimeOptions::defined_options_[] = {

{ "mixtureFile", OptionOptional::OPTIONAL, OptionArrayType::SINGULAR, OptionArgumentType::STRING, "mixture.txt",
R"("The mixture file was generated by Zhu, Almagro-Garcia and McVean using Deploid and describes
      the mixture status (complexity of infection) of the Pf3k samples. Only use this option when processing Pf3k samples.")"},

{ "vcf_ploidy", OptionOptional::OPTIONAL, OptionArrayType::SINGULAR, OptionArgumentType::INTEGER, "2",
R"("The ploidy of any input VCF files (this need not be the ploidy of the organism).")"},

};


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Reads and validates all the options defined in the specified option file.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


bool kgl::RuntimeOptions::getRuntimeOption(const RuntimeOptionTag& option, RuntimeOptionVector& option_values) const {


  auto result = getMap().find(option);

  if (result == getMap().end()) {

    option_values.clear();
    return false;

  }

  option_values = result->second;
  return true;

}


bool kgl::RuntimeOptions::readRuntimeOptions(const std::string& file_name) {

  std::ifstream readfile(file_name);

  if (not readfile.good()) {

    ExecEnv::log().critical("RuntimeOptions::readRuntimeOptions; could not open options file: {}", file_name);
    return false; // never reached.

  }

  bt::char_separator<char> item_key_sep(FIELD_DELIMITER_);
  size_t line_count = 0;

  while (true) {

    std::string record_str;
    if (std::getline(readfile, record_str).eof()) break;

    if ((record_str)[0] == COMMENT_CHAR_) continue;   // Ignore comment lines.

    ++line_count;
    std::vector<std::string> field_vector;
    bt::tokenizer<bt::char_separator<char>> tokenize_item(record_str, item_key_sep);

    for(auto iter_item = tokenize_item.begin(); iter_item != tokenize_item.end(); ++iter_item) {

      field_vector.push_back(*iter_item);

    }

    if (field_vector.empty()) continue;  // Skip any blank lines.

    RuntimeOptionTag option = field_vector.front();
    RuntimeOptionVector arguments = field_vector;
    arguments.erase(arguments.begin()); // Erase the first element (the option name).

    if (not parseOption(option, arguments)) {

      ExecEnv::log().critical("RuntimeOptions::readRuntimeOptions; Error Parsing Options file: {}, line number: {} line: {}",
                              file_name, line_count, record_str);
      return false; // never reached.

    }

    std::pair<RuntimeOptionTag, RuntimeOptionVector> insert_option(option, arguments);
    auto result = runtime_option_map_.insert(insert_option);

    if (not result.second) {

      std::stringstream ss;
      printHelp(ss);
      ExecEnv::log().info("{}", ss.str());
      ExecEnv::log().critical("RuntimeOptions::readRuntimeOptions; Duplicate Option, file: {}, line number: {} line: {}",
                              file_name, line_count, record_str);

    }

  }

  if (not checkRequiredOptions()) {

    ExecEnv::log().critical("RuntimeOptions::readRuntimeOptions; Required option missing from options file: {}", file_name);
    return false; // never reached

  }

  readfile.close();
  ExecEnv::log().info("RuntimeOptions::readRuntimeOptions; Options file: {}, read: {} options", file_name, line_count);
  return true;

}


void kgl::RuntimeOptions::printHelp(std::ostream& stream) {

  stream << "Valid KGL Program Options Defined for the Options File" << '\n';
  stream << "======================================================" << '\n';

  for (auto option : defined_options_) {

    stream << '\n';
    stream << "OPTION: " << option.name << '\n';
    stream << "Required/Optional: ";
    stream << (option.optional == OptionOptional::REQUIRED ? "Required" : "Optional");
    stream << '\n';
    stream << "Option Array Type: ";
    switch(option.option_array_type) {

      case OptionArrayType::ARRAY:
        stream << "Array (1..n arguments)";
        break;

      case OptionArrayType::SINGULAR:
        stream << "Singular (1 argument)";
        break;

      case OptionArrayType::FLAG:
        stream << "Flag (no arguments)";
        break;

    }
    stream << '\n';
    stream << "OptionArgumentType: ";
    switch(option.option_arument_type) {

      case OptionArgumentType::STRING:
        stream << "String";
        break;

      case OptionArgumentType::INTEGER:
        stream << "Integer";
        break;

      case OptionArgumentType::FLOAT:
        stream << "Float";
        break;

    }
    stream << '\n';
    stream << "Description: ";
    stream << option.option_description << "\n\n";

  }

}


bool kgl::RuntimeOptions::parseOption(const RuntimeOptionTag& option, const RuntimeOptionVector& arguments) {

  PredefinedOptionType defined_option;
  if (not getDefinedOption(option, defined_option)) {

    ExecEnv::log().error("RuntimeOptions::parseOption; option: {} is unknown (not defined)", option);
    std::stringstream ss;
    printHelp(ss);
    ExecEnv::log().info("{}", ss.str());
    return false;
  }

  return true;

}
